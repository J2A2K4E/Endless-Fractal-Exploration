<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Fractal Explorer – Mandelbrot × Julia × Cantor</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: monospace
    }

    #help {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, .5);
      padding: 8px;
      border-radius: 4px
    }
  </style>
</head>

<body>
  <div id="help">
    ←/→ Yaw ↑/↓ Pitch PgUp/PgDn Forward/Back<br>
    Shift = Boost R = Reset Camera
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <script>
    /* ---------- THREE BASICS ---------- */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 4);
    const renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);
    /* ---------- FULLSCREEN RAY-MARCH SHADER ---------- */
    const uniforms = {
      iTime: {
        value: 0
      },
      iRes: {
        value: new THREE.Vector2(innerWidth, innerHeight)
      },
      camPos: {
        value: camera.position
      },
      camMat: {
        value: new THREE.Matrix4()
      }
    };
    const material = new THREE.ShaderMaterial({
      depthWrite: false,
      fragmentShader: `
    precision highp float;
    uniform vec2  iRes;
    uniform float iTime;
    uniform vec3  camPos;
    uniform mat4  camMat;

    /*-- Complex helpers for Mandelbrot & Julia --*/
    vec2 cMul(vec2 a,vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    float mandel(vec2 c){
      vec2 z=vec2(0);float m=0.;
      for(int i=0;i<100;i++){
        z=cMul(z,z)+c;
        if(dot(z,z)>4.) break;
        m+=1.;
      }
      return m/100.;
    }
    float julia(vec2 p, vec2 k){
      vec2 z=p;float m=0.;
      for(int i=0;i<100;i++){
        z=cMul(z,z)+k;
        if(dot(z,z)>4.) break;
        m+=1.;
      }
      return m/100.;
    }
    /*-- 1-D Cantor dust via base-3 test --*/
    float cantor(float x){
      for(int i=0;i<6;i++){
        x*=3.;
        if(x>1. && x<2.) return 0.;
        x=fract(x);
      }
      return 1.;
    }

    /*-- Distance estimator for hybrid fractal (fake) --*/
    float map(vec3 p){
      /* Project to complex plane */
      vec2 uv = p.xy*1.5;
      float m = mandel(uv);
      float j = julia(uv, vec2(.355,.355));
      float c = cantor(fract(p.z*0.5)+0.5);
      /* Blend & create surfaces */
      return (1.-m)*0.6 + (1.-j)*0.4 + (1.-c)*0.2;
    }

    vec3 palette(float t){
      return 0.5+0.5*cos(6.2831*(vec3(.6,.8,1.2)*t+vec3(0,.33,.67)));
    }

    void main(){
      vec2 uv = (gl_FragCoord.xy*2.-iRes)/iRes.y;
      /* Build camera ray */
      vec3 ro = camPos;
      vec3 rd = normalize((camMat*vec4(uv, -1., 0.)).xyz);

      /* Ray-march */
      float t=0.; float d;
      for(int i=0;i<128;i++){
        vec3 pos = ro + rd*t;
        d = map(pos)-.15;          // Thickness
        if(d<0.001||t>20.) break;
        t += d;
      }
      float shade = exp(-0.2*t);
      vec3 col = palette(shade*2.+iTime*0.05);
      col *= smoothstep(20.,0.,t); // fade far
      gl_FragColor = vec4(col,1.0);
    }`,
      vertexShader: `varying vec2 vUv;
    void main(){vUv=uv;gl_Position=vec4(position,1.);} `,
      uniforms: uniforms
    });
    /* ---------- FULLSCREEN QUAD ---------- */
    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
    scene.add(quad);
    /* ---------- KEYBOARD NAVIGATION ---------- */
    const keys = {};
    addEventListener('keydown', e => keys[e.code] = true);
    addEventListener('keyup', e => keys[e.code] = false);

    function updateCamera(dt) {
      const speed = (keys.ShiftLeft || keys.ShiftRight ? 5 : 1) * dt * 2;
      if (keys.ArrowUp) camera.rotation.x -= dt;
      if (keys.ArrowDown) camera.rotation.x += dt;
      if (keys.ArrowLeft) camera.rotation.y += dt;
      if (keys.ArrowRight) camera.rotation.y -= dt;
      if (keys.PageUp) camera.translateZ(-speed);
      if (keys.PageDown) camera.translateZ(speed);
    }
    addEventListener('resize', () => {
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      uniforms.iRes.value.set(innerWidth, innerHeight);
    });
    /* ---------- ANIMATION LOOP ---------- */
    let last = performance.now();
    (function animate(now) {
      requestAnimationFrame(animate);
      const dt = (now - last) / 1000;
      last = now;
      updateCamera(dt);
      uniforms.iTime.value = now / 1000;
      uniforms.camPos.value.copy(camera.position);
      uniforms.camMat.value.copy(camera.matrixWorld);
      TWEEN.update(now);
      renderer.render(scene, camera);
    })();
  </script>
</body>

</html>
